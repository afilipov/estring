
#include "math.h"
#include "error.h"

/*
#ifdef INTERNAL
printf (arg1)
const char *arg1;
{
  while (*arg1 != 0)
  {
  iputchar (*arg1++);
  }
}
#endif
*/

	.asm
	.linklist
	.symbols
	.endasm

/******************************************************************************
*   T A Y L O R  S E R I E S  A P P R O X A M A T I O N  F O R  S I N E       *
*******************************************************************************

              Copyright (C) 1986 by 2500 A.D. Software, Inc.
                                                  
   This Taylor series approximation for the sine function takes a double argu-
   ment which must be given in radians.  First the argument is transformed by
   range reduction.  Then the transformed argument is used in a DO loop to 
   generate terms of the series.  The generation of terms is made more 
   efficient by the use of nested multiplication.  When the last term 
   generated by the series is less than the desired accuracy, the loop 
   terminates, and the function returns a double precision floating point
   number. */ 

/*
#define DEBUG_MESSAGES  1
*/

extern const double pi, two_pi, pi_4;           /* pi */
extern const double pi_2;                       /* pi divided by 2 */
extern const double i_pi_2;                     /* inverse of pi_2 */

#ifdef INTERNAL
extern const double _double_precision;	 	/* result precision */
#else
extern double _double_precision;	 	/* result precision */
#endif

/*
main ()
{
double k;
double sin_sum = 0.0;
double final_sin_sum = 0.7071067811865423546;
double fabs ();
double sin ();

#ifndef INTERNAL
double *f_ptr;
int i;
char   *conv_ptr;
char print_sin_sum = 1;
#endif

printf ("Sin Test\n");

  for (k = -two_pi; k < 18.0; k += pi_4)
  {

  sin_sum += sin (k);
printf (".");

#ifdef DEBUG_MESSAGES
#ifndef INTERNAL
  f_ptr = &j;
  conv_ptr = (char *) f_ptr;
    for (i = 0; i != 8; i++)
    printf ("conv_ptr -> %x\n", (*(conv_ptr + i) & 0x00ff));
#endif
#endif

#ifndef INTERNAL
  if (print_sin_sum != 0)
  printf ("The sin of %f = %f\n", k, sin (k));
#endif
  }
  
#ifndef INTERNAL
  if (print_sin_sum != 0)
  printf ("sin_sum == %.40e\n", sin_sum);
#endif

  if (fabs (sin_sum - final_sin_sum) < 1.0e-13)
  {
  printf ("Sin Test Passed\n");
  }
  else
  {
  printf ("\n*****************ERROR IN SIN TEST\n");
  }
}
*/


double sin (radians)
double radians;
{
int k, temp1 = 0;
double term, temp2;
double sum;
double u, temp, v;
double fabs ();

  if (radians > HUGE) 
  {
  errno = EDOM;
  return (HUGE);
  }

u = i_pi_2 * radians;
temp = 0.25 * (u + 1.0);                  	/* reduce the argument */
temp1 = i_floor(temp);
v = u - (4.0 * temp1);
  if (v <= 1.0)
  {
  radians = v;
  }
  else
  {
  radians = 2.0 - v;
  }

radians *= pi_2;
sum = radians;             /* set sum and term to the first term value */
term = radians;            /* this eliminates the need to calculate the */
k = 1;                     /* first term */ 

/* HERE FOR THE SERIES GENERATION */

  do
  {
  temp2 = 2.0 * k;
  term  = (-term * sqr(radians)) / ((temp2) * (temp2 + 1.0));
  sum += term;
  k++;

#ifdef DEBUG_MESSAGES
printf ("radians = %g, sqr(radians) = %g, temp2 = %g, term = %g\n", radians, sqr(radians), temp2, term);
#endif

  }
  while (fabs(term) >= _double_precision);

  if (fabs (sum) > ((_double_precision * 5.0e3) + 1.0))
  {
  errno = ERANGE;
  return (HUGE);
  }
  
  if (fabs(sum) < 1.0e-13)
  {
  return (0.0);
  }

return (sum);
}

